## 单例模式
场景：某些对象只需要创建一次，全局使用该对象都是同一个对象
实现：用一个变量标志当前已经为某个类创建过对象，是，返回该对象，否，创建对象
缺点：我得知道这是一个单例类，才知道怎么用
```js
var Singleton = function(name) {
  this.name = name;
}
Singleton.instance = null;
Singleton.prototype.getName = function() {
  return this.name
}
Singleton.getInstance = function(name) {
  if(!this.instance) {
    this.instance = new Singleton(name)
  } 
  return this.instance
}
```
### 代理实现单例模式
思想：单一职责原则
```js
var CreateDiv = function(html) {
  this.html = html;
  this.init()
}
CreateDiv.prototype.init = function() {
  var div = document.createElement('div')
  div.innerHTML = this.html
  document.body.appendChild(div)
}

var ProxySingletonCreateDiv = (function() {
  var instance;
  return function(html) {
    if(!instance) {
      instance = new CreateDiv(html)
    }
    return instance
  }
})()
```

## 策略模式
思想：定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。
实现：一个基于策略模式的程序至少由两部分组成。
- 第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
- 第二部分是环境类context，context接收客户的请求，随后把请求委托给一个策略类。
```js
var strategies = {
  'S': function(salary) {
    return salary * 4;
  },
  'A': function(salary) {
    return salary * 3
  },
  "B": function(salary) {
    return salary * 2
  }
}

var calculateBouns = function() {
  return strategies[level](salary)
}
```