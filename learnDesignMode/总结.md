## 单例模式
场景：某些对象只需要创建一次，全局使用该对象都是同一个对象
实现：用一个变量标志当前已经为某个类创建过对象，是，返回该对象，否，创建对象
缺点：我得知道这是一个单例类，才知道怎么用
```js
var Singleton = function(name) {
  this.name = name;
}
Singleton.instance = null;
Singleton.prototype.getName = function() {
  return this.name
}
Singleton.getInstance = function(name) {
  if(!this.instance) {
    this.instance = new Singleton(name)
  } 
  return this.instance
}

var danli1 = Singleton.getInstance('陈冠希')
var danli2 = Singleton.getInstance('陈冠希')
danli1 === danli2
```

## 策略模式
思想：定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。
实现：一个基于策略模式的程序至少由两部分组成。
- 第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
- 第二部分是环境类context，context接收客户的请求，随后把请求委托给一个策略类。
```js
var strategies = {
  'S': function(salary) {
    return salary * 4;
  },
  'A': function(salary) {
    return salary * 3
  },
  "B": function(salary) {
    return salary * 2
  }
}

var calculateBouns = function(level,salary) {
  return strategies[level](salary)
}
calculateBouns("S",1000)
```

## 代理模式
思想：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制这个对象的访问。客户实际访问的是替身对象
```js
// 文件同步案例
var syncFile = function(id) {
  console.log('开始同步文件，id为:' + id)
}

var proxySyncFile = (function() {
  var cache = [] // 保存一段时间内需要同步的id
  var timer;

  return function(id) {
    cache.push(id)
    if(timer) {
      return
    }
    timer = setTimeout(function() {
      syncFile(cache.join(','))
      clearTimeout(timer)
      timer = null
      cache = []
    },2000)
  }
})()

proxySyncFile('123abc')
```

## 迭代器模式
```js
// 内部迭代
var each = function(ary,callback) {
  for(var i=0;i<ary.length;i++) {
    callback.call(ary[i],i,ary[i])
  }
}

each([1,2,3],function(i,n) {
  console.log(i,n)
})
```

## 发布订阅模式
```js
var event = {
  clientList: {},
  listen: function (key, fn) {
    if (!this.clientList[key]) {
      this.clientList[key] = []
    }
    this.clientList[key].push(fn);
  },
  trigger: function () {
    var key = Array.prototype.shift.call(arguments);
    var fns = this.clientList[key]
    if (!fns || fns.listen === 0) {
      return false;
    }

    for (var i = 0; i < fns.length; i++) {
      var fn = fns[i];
      fn.apply(this,arguments);
    }
  }
}

// 给对象动态安装发布-订阅功能
var installEvent = function(obj) {
  for(var i in event) {
    obj[i] = event[i]
  }
}

// 测试
var salesOffices = {};
installEvent(salesOffices)

salesOffices.listen('squareMeter88', function(price) {
  console.log('88平房子价格 =',price)
})

salesOffices.listen('squareMeter120', function(price) {
  console.log('120平房子价格 =',price)
})

salesOffices.trigger('squareMeter88', 20000)
salesOffices.trigger('squareMeter120', 40000)
```

## 命令模式
