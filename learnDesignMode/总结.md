## 单例模式
场景：某些对象只需要创建一次，全局使用该对象都是同一个对象
实现：用一个变量标志当前已经为某个类创建过对象，是，返回该对象，否，创建对象
缺点：我得知道这是一个单例类，才知道怎么用
```js
var Singleton = function(name) {
  this.name = name;
}
Singleton.instance = null;
Singleton.prototype.getName = function() {
  return this.name
}
Singleton.getInstance = function(name) {
  if(!this.instance) {
    this.instance = new Singleton(name)
  } 
  return this.instance
}

var danli1 = Singleton.getInstance('陈冠希')
var danli2 = Singleton.getInstance('陈冠希')
danli1 === danli2
```


## 策略模式
思想：定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。
实现：一个基于策略模式的程序至少由两部分组成。
- 第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
- 第二部分是环境类context，context接收客户的请求，随后把请求委托给一个策略类。
```js
var strategies = {
  'S': function(salary) {
    return salary * 4;
  },
  'A': function(salary) {
    return salary * 3
  },
  "B": function(salary) {
    return salary * 2
  }
}

var calculateBouns = function(level,salary) {
  return strategies[level](salary)
}
calculateBouns("S",1000)
```
## 代理模式
思想：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制这个对象的访问。客户实际访问的是替身对象
```js
// 文件同步案例
var syncFile = function(id) {
  console.log('开始同步文件，id为:' + id)
}

var proxySyncFile = (function() {
  var cache = [] // 保存一段时间内需要同步的id
  var timer;

  return function(id) {
    cache.push(id)
    if(timer) {
      return
    }
    timer = setTimeout(function() {
      syncFile(cache.join(','))
      clearTimeout(timer)
      timer = null
      cache = []
    },2000)
  }
})()

proxySyncFile('123abc')
```

## 迭代器模式
